#include <stdio.h>
#include "CommonType.h"
#include "skf.h"
#include "dev_rsa_funs.h"

// 几个结构体说明

/*==>RSAPUBLICKEYBLOB RSA公钥结构
typedef struct Struct_RSAPUBLICKEYBLOB{
	ULONG AlgID;							// RSA算法标识  SGD_RSA;
	ULONG BitLen;							// 算法模长		1024
	BYTE Modulus[MAX_RSA_MODULUS_LEN];		// Modulus的后128位存放 算法的模数N
	BYTE PublicExponent[4];					// 公开密钥 e	00010001
}RSAPUBLICKEYBLOB, *PRSAPUBLICKEYBLOB;
<==*/


/*==>RSAPUBLICKEYBLOB RSA公钥结构
typedef struct Struct_RSAPRIVATEKEYBLOB{
	ULONG AlgID;									// RSA算法标识  SGD_RSA;
	ULONG BitLen;									// 算法模长		1024
	BYTE Modulus[MAX_RSA_MODULUS_LEN];				//模数N
	BYTE PublicExponent[MAX_RSA_EXPONENT_LEN];		//e
	BYTE PrivateExponent[MAX_RSA_MODULUS_LEN];		//私钥D
	BYTE Prime1[MAX_RSA_MODULUS_LEN/2];				//p  1024模式下P为64字节,存放在Prime1的后64位
	BYTE Prime2[MAX_RSA_MODULUS_LEN/2];				//q	 1024模式下Q为64字节,存放在Prime2的后64位
	BYTE Prime1Exponent[MAX_RSA_MODULUS_LEN/2];		//dp 1024模式下DP为64字节,存放在Prime1Exponent的后64位
	BYTE Prime2Exponent[MAX_RSA_MODULUS_LEN/2];		//dq 1024模式下DQ为64字节,存放在Prime2Exponent的后64位
	BYTE Coefficient[MAX_RSA_MODULUS_LEN/2];		//coef 1024模式下coef为64字节,存放在Coefficient的后64位
}RSAPRIVATEKEYBLOB, *PRSAPRIVATEKEYBLOB;
<==*/

//用于RSA加解密填充
int rsa_padding_add_PKCS1_type_2_self(unsigned char *to, int tlen, const unsigned char *from, int flen);
void dev_rsa_funs_test()
{
    ULONG rv = 0;
    HANDLE hKey = NULL;

    RSAPUBLICKEYBLOB tRSAPubBlob;
    ULONG ulContainerType = 0, ulBitsLen = 0;

    BYTE bySignData[117] = {0}, bySignature[128] = {0};
    ULONG ulSignDataLen = 117, ulSignatureLen = 128;

    RSAPUBLICKEYBLOB tExtRSAPubBlob;
    BYTE byModulus[] = {
            0xB9,0x0F,0x1B,0x62,0x53,0xEF,0xDE,0x77,0x1A,0xE6,0x70,0xEA,0x2E,0xF6,0xC6,0x24,
            0xA1,0x73,0x77,0xE3,0x9F,0x4A,0x2D,0x8C,0x55,0x6D,0x04,0xA8,0x19,0x1E,0xCE,0x24,
            0x2F,0xE4,0x83,0x26,0x78,0x4B,0x1E,0x75,0x3A,0xA6,0x0C,0x80,0x31,0x6C,0x10,0xC4,
            0x54,0x32,0x0A,0xF0,0x9F,0xAE,0x5C,0x6C,0x9D,0xD7,0x92,0xE8,0x4B,0xE4,0xA9,0xA5,
            0x15,0x86,0xF7,0x1B,0x2C,0xB6,0x82,0x19,0x76,0x0D,0x23,0x35,0x99,0xC8,0x5B,0x16,
            0x99,0xA3,0x26,0x91,0x9B,0x74,0x79,0xD3,0x3A,0xD0,0xC9,0x86,0xC4,0x13,0xD0,0x9C,
            0x77,0x8E,0x29,0x16,0x00,0x50,0x62,0xF0,0x2B,0xB6,0xA2,0xE2,0xA6,0x42,0x3F,0xC8,
            0xBA,0x3E,0x75,0xA5,0x41,0xB3,0x06,0x62,0xBF,0xE7,0xA6,0x68,0xE0,0x0C,0x4A,0x63
    };
    BYTE byE[] = {0x00,0x01,0x00,0x01};
    BYTE byInData[128] = {0}, byOutData[128] = {0};
    ULONG byInDataLen = 128, byOutDataLen = 128;

    RSAPRIVATEKEYBLOB tExtRSAPriBlob;
    BYTE byP[] = {
            0xDA,0x73,0x7D,0xCB,0x35,0x3E,0x2F,0x19,0x38,0x91,0x41,0x70,0xC0,0xF0,0x35,0x42,
            0x08,0x71,0x54,0x1C,0x3F,0x0B,0x1D,0xB6,0xF6,0x2F,0xF6,0x29,0x26,0x2C,0xC2,0xEA,
            0xE0,0xF7,0x7C,0xAF,0x87,0x68,0xD6,0xC2,0x90,0x30,0xD5,0x1B,0x1D,0x3B,0xE7,0x41,
            0x70,0x5A,0xFE,0x88,0x49,0x00,0xD6,0x00,0x45,0x8D,0x5E,0xB4,0xC5,0x5D,0x96,0xD7
    };
    BYTE byQ[] = {
            0xD8,0xDE,0x42,0xE8,0x0B,0x5D,0x9B,0x57,0x1E,0xCC,0x44,0xAF,0xAE,0xBC,0xDC,0x78,
            0xB7,0xFC,0xE4,0x76,0x79,0xBE,0x87,0xDD,0xF2,0x50,0xB8,0x92,0x8A,0x36,0x04,0x23,
            0x59,0xB2,0x4F,0x74,0x54,0xC0,0x5C,0xAD,0xB4,0xE7,0xAE,0xF4,0xBD,0xEC,0xD1,0x8A,
            0x9A,0x69,0x31,0xE1,0xDC,0x55,0xF1,0x7D,0x52,0x0F,0xC1,0x00,0x69,0xCA,0xD3,0x55
    };
    BYTE byDP[] = {
            0x03,0xFF,0x1E,0xEB,0x0B,0xD3,0x52,0x6B,0x44,0xB4,0xAB,0x9C,0xD3,0x7A,0xD1,0x8E,
            0x9E,0xB6,0xEC,0x12,0x04,0x39,0x40,0xD6,0xEB,0x14,0x1F,0x8D,0xCB,0x2C,0x00,0x78,
            0xE9,0x9A,0xBD,0x86,0x3C,0x94,0xF7,0x70,0xE1,0xD0,0x72,0xE5,0xA7,0x18,0x44,0x77,
            0xD7,0x05,0x63,0x28,0xBD,0x25,0x2D,0xC5,0x1D,0x80,0xA3,0x9D,0xED,0x0A,0x74,0x4B
    };
    BYTE byDQ[] = {
            0x1A,0x3D,0xBA,0xA6,0xCD,0x49,0x44,0x54,0xA4,0x5B,0x5F,0x2C,0x4A,0xDE,0x7B,0x66,
            0xF8,0x0C,0x57,0xB0,0xA6,0x46,0x91,0xB6,0x1F,0x6D,0xF9,0x07,0x72,0x45,0xDA,0xF6,
            0x54,0x12,0x29,0x5F,0x10,0x2A,0x3E,0x8C,0x9E,0x49,0x32,0x78,0x56,0xCA,0xE3,0x07,
            0xFC,0x6B,0x22,0x28,0x0C,0x3B,0x31,0xFF,0x52,0x00,0xA9,0xFF,0xDC,0xCD,0x38,0x09
    };
    BYTE byINV[] = {
            0x38,0x12,0x0A,0xC9,0xF4,0x0F,0x9F,0x5E,0xC0,0xB5,0xE6,0x3D,0xC7,0xCB,0x4B,0x90,
            0xB7,0xED,0x76,0x22,0x34,0xE7,0xEF,0x2E,0xAD,0x2B,0xB7,0xC1,0xD3,0x31,0x60,0xC5,
            0x4D,0x51,0xD0,0x08,0x10,0x4F,0xA2,0x19,0x99,0xAE,0x00,0x2E,0x84,0x1E,0x31,0xE6,
            0x8C,0x71,0xD2,0x70,0xBD,0x2E,0xD7,0xAA,0xEB,0x77,0x5B,0x84,0x54,0xED,0x2D,0x16
    };

    BYTE bySymKey[16] = {0x1B,0x2F,0x2C,0x72,0xBB,0x43,0x5E,0xAD,0xED,0xDB,0x8B,0x80,0x70,0x0A,0x4F,0x64};
    BYTE bySymKeyFinal[128] = {0};
    BYTE byRSAPrikeyBlobCipher[2048] = {0};
    ULONG ulRSAPrikeyBlobCipherLen = 0;
    BLOCKCIPHERPARAM EncParam;
    //BYTE RSAPriKey[] = {		// P||Q||DP||DQ||INV
    //	0xDA,0x73,0x7D,0xCB,0x35,0x3E,0x2F,0x19,0x38,0x91,0x41,0x70,0xC0,0xF0,0x35,0x42,
    //	0x08,0x71,0x54,0x1C,0x3F,0x0B,0x1D,0xB6,0xF6,0x2F,0xF6,0x29,0x26,0x2C,0xC2,0xEA,
    //	0xE0,0xF7,0x7C,0xAF,0x87,0x68,0xD6,0xC2,0x90,0x30,0xD5,0x1B,0x1D,0x3B,0xE7,0x41,
    //	0x70,0x5A,0xFE,0x88,0x49,0x00,0xD6,0x00,0x45,0x8D,0x5E,0xB4,0xC5,0x5D,0x96,0xD7,
    //	0xD8,0xDE,0x42,0xE8,0x0B,0x5D,0x9B,0x57,0x1E,0xCC,0x44,0xAF,0xAE,0xBC,0xDC,0x78,
    //	0xB7,0xFC,0xE4,0x76,0x79,0xBE,0x87,0xDD,0xF2,0x50,0xB8,0x92,0x8A,0x36,0x04,0x23,
    //	0x59,0xB2,0x4F,0x74,0x54,0xC0,0x5C,0xAD,0xB4,0xE7,0xAE,0xF4,0xBD,0xEC,0xD1,0x8A,
    //	0x9A,0x69,0x31,0xE1,0xDC,0x55,0xF1,0x7D,0x52,0x0F,0xC1,0x00,0x69,0xCA,0xD3,0x55,
    //	0x03,0xFF,0x1E,0xEB,0x0B,0xD3,0x52,0x6B,0x44,0xB4,0xAB,0x9C,0xD3,0x7A,0xD1,0x8E,
    //	0x9E,0xB6,0xEC,0x12,0x04,0x39,0x40,0xD6,0xEB,0x14,0x1F,0x8D,0xCB,0x2C,0x00,0x78,
    //	0xE9,0x9A,0xBD,0x86,0x3C,0x94,0xF7,0x70,0xE1,0xD0,0x72,0xE5,0xA7,0x18,0x44,0x77,
    //	0xD7,0x05,0x63,0x28,0xBD,0x25,0x2D,0xC5,0x1D,0x80,0xA3,0x9D,0xED,0x0A,0x74,0x4B,
    //	0x1A,0x3D,0xBA,0xA6,0xCD,0x49,0x44,0x54,0xA4,0x5B,0x5F,0x2C,0x4A,0xDE,0x7B,0x66,
    //	0xF8,0x0C,0x57,0xB0,0xA6,0x46,0x91,0xB6,0x1F,0x6D,0xF9,0x07,0x72,0x45,0xDA,0xF6,
    //	0x54,0x12,0x29,0x5F,0x10,0x2A,0x3E,0x8C,0x9E,0x49,0x32,0x78,0x56,0xCA,0xE3,0x07,
    //	0xFC,0x6B,0x22,0x28,0x0C,0x3B,0x31,0xFF,0x52,0x00,0xA9,0xFF,0xDC,0xCD,0x38,0x09,
    //	0x38,0x12,0x0A,0xC9,0xF4,0x0F,0x9F,0x5E,0xC0,0xB5,0xE6,0x3D,0xC7,0xCB,0x4B,0x90,
    //	0xB7,0xED,0x76,0x22,0x34,0xE7,0xEF,0x2E,0xAD,0x2B,0xB7,0xC1,0xD3,0x31,0x60,0xC5,
    //	0x4D,0x51,0xD0,0x08,0x10,0x4F,0xA2,0x19,0x99,0xAE,0x00,0x2E,0x84,0x1E,0x31,0xE6,
    //	0x8C,0x71,0xD2,0x70,0xBD,0x2E,0xD7,0xAA,0xEB,0x77,0x5B,0x84,0x54,0xED,0x2D,0x16
    //};

    rv = SKF_DeleteContainer(hApplication, "Test_Container");
    rv = SKF_CreateContainer(hApplication, "Test_Container", &hContainer);

    // 生成RSA签名密钥对
    // ulBitsLen 为模长 1024/2048, pubBlob为导出的RSA公钥
    ulBitsLen = 1024;
    rv = SKF_GenRSAKeyPair(hContainer, ulBitsLen, &tRSAPubBlob);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_GenRSAKeyPair Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    rv = SKF_GetContainerType(hContainer, &ulContainerType);
    PrintMsg("SKF_GenRSAKeyPair ContainerType[%u] OK\n", ulContainerType);

    // RSA签名
    // bySignData签名数据, ulSignDataLen签名数据长度,不大于密钥模长-11, bySignature签名结果,ulSignatureLen签名结果长度
    rv = SKF_RSASignData(hContainer, bySignData, ulSignDataLen, bySignature, &ulSignatureLen);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_RSASignData Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_RSASignData OK\n");

    // RSA验签
    // ulSignatureLen签名结果长度,为公钥模长; tRSAPubBlob为验签使用的签名公钥
    rv = SKF_RSAVerify(hDev, &tRSAPubBlob, bySignData, ulSignDataLen, bySignature, ulSignatureLen);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_RSAVerify Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_RSAVerify OK\n");

    // RSA外来公钥运算(加密)
    // tExtRSAPubBlob为外来公钥, byInData为待运算数据,byInDataLen为待运算数据长度,必须为模长,不足补齐,byOutData为运算结果数据,byOutDataLen运算结果数据长度
    tExtRSAPubBlob.AlgID = SGD_RSA;
    tExtRSAPubBlob.BitLen = 1024;
    memcpy(tExtRSAPubBlob.Modulus + 128, byModulus, sizeof(byModulus));
    memcpy(tExtRSAPubBlob.PublicExponent, byE, sizeof(byE));
    memset(byInData, 0x05, byInDataLen);
    rv = SKF_ExtRSAPubKeyOperation(hDev, &tExtRSAPubBlob, byInData, byInDataLen, byOutData, &byOutDataLen);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_ExtRSAPubKeyOperation Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_ExtRSAPubKeyOperation OK\n");

    // RSA外来私钥运算(解密)
    tExtRSAPriBlob.AlgID = SGD_RSA;
    tExtRSAPriBlob.BitLen = 1024;
    memcpy(tExtRSAPriBlob.Prime1 + 64, byP, sizeof(byP));
    memcpy(tExtRSAPriBlob.Prime2 + 64, byQ, sizeof(byQ));
    memcpy(tExtRSAPriBlob.Prime1Exponent + 64, byDP, sizeof(byDP));
    memcpy(tExtRSAPriBlob.Prime2Exponent + 64, byDQ, sizeof(byDQ));
    memcpy(tExtRSAPriBlob.PublicExponent, byE, sizeof(byE));
    memcpy(tExtRSAPriBlob.Coefficient + 64, byINV, sizeof(byINV));
    rv = SKF_ExtRSAPriKeyOperation(hDev, &tExtRSAPriBlob, byOutData, byOutDataLen, byInData, &byInDataLen);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_ExtRSAPriKeyOperation Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_ExtRSAPriKeyOperation OK\n");

    // RSA生成并导出会话密钥
    // 使用tExtRSAPubBlob加密产生的会话密钥, 返回加密结果密文byOutData和会话密钥句柄hKey
    rv = SKF_RSAExportSessionKey(hContainer, SGD_SM1_ECB, &tExtRSAPubBlob, byOutData, &byOutDataLen, &hKey);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_RSAExportSessionKey Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_RSAExportSessionKey OK\n");
    rv = SKF_CloseHandle(hKey);

    // 导入RSA加密密钥对
    //==> 以下模拟 应用方 获取会话密钥密文、私钥密文过程
    // 将密钥填充到算法模长长度
    rsa_padding_add_PKCS1_type_2_self(bySymKeyFinal, 128, bySymKey, 16);
    // 使用签名公钥加密会话密钥, 得到会话密钥密文
    rv = SKF_ExtRSAPubKeyOperation(hDev, &tRSAPubBlob, bySymKeyFinal, 128, byOutData, &byOutDataLen);
    // 使用会话密钥加密RSA私钥
    rv = SKF_SetSymmKey(hDev, bySymKey, SGD_SM1_ECB, &hKey);
    EncParam.IVLen = 0;
    EncParam.PaddingType = 1;
    rv = SKF_EncryptInit(hKey, EncParam);
    rv = SKF_Encrypt(hKey, (BYTE*)&tExtRSAPriBlob, sizeof(RSAPRIVATEKEYBLOB), NULL, &ulRSAPrikeyBlobCipherLen);
    rv = SKF_Encrypt(hKey, (BYTE*)&tExtRSAPriBlob, sizeof(RSAPRIVATEKEYBLOB), byRSAPrikeyBlobCipher, &ulRSAPrikeyBlobCipherLen);
    rv = SKF_CloseHandle(hKey);
    //<== end
    rv = SKF_ImportRSAKeyPair(hContainer, SGD_SM1_ECB, byOutData, byOutDataLen, byRSAPrikeyBlobCipher, ulRSAPrikeyBlobCipherLen);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_ImportRSAKeyPair Wrong\n");
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_ImportRSAKeyPair OK\n");

    // 加密公钥对会话密钥加密, 得到会话密钥密文
    //==> 以下模拟 应用方使用SKF_ImportECCKeyPair导入的公私钥对中的公钥对会话密钥加密
    memset(byOutData, 0x00, 128);
    rv = SKF_ExtRSAPubKeyOperation(hDev, &tExtRSAPubBlob, bySymKeyFinal, 128, byOutData, &byOutDataLen);
    //<== end
    // SGD_SM1_ECB标识会话密钥算法标识, byOutData为使用加解密密钥对公钥对会话密钥加密后的密文
    rv = SKF_ImportSessionKey (hContainer, SGD_SM1_ECB, byOutData, byOutDataLen, &hKey);
    if (rv != SAR_OK)
    {
        PrintMsg("SKF_ImportSessionKey Wrong,%04x\n", rv);
        fflush(stdin);
        getchar();
        return ;
    }
    PrintMsg("SKF_ImportSessionKey OK\n");
    rv = SKF_CloseHandle(hKey);
    rv = SKF_CloseContainer(hContainer);
}

int rsa_padding_add_PKCS1_type_2_self(unsigned char *to, int tlen, const unsigned char *from, int flen)
{
    int i,j;
    unsigned char *p;

    if (flen > (tlen-11))
    {
        return(-1);
    }

    p=(unsigned char *)to;

    *(p++)=0;
    *(p++)=2;
    j=tlen-3-flen;
    for(i = 0; i <j ; i++)
    {
        do
        {
            *p = rand() & 0xff;
        } while (*p == '\0');
        p++;
    }

    *(p++)='\0';

    memcpy(p,from,(unsigned int)flen);
    return(0);
}