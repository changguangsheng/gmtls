#include <stdio.h>
#include "CommonType.h"
#include "skf.h"
#include "dev_rsa_funs.h"

// 几个结构体说明

/*==>RSAPUBLICKEYBLOB RSA公钥结构
typedef struct Struct_RSAPUBLICKEYBLOB{
	ULONG AlgID;							// RSA算法标识  SGD_RSA;		
	ULONG BitLen;							// 算法模长		1024	
	BYTE Modulus[MAX_RSA_MODULUS_LEN];		// Modulus的后128位存放 算法的模数N
	BYTE PublicExponent[4];					// 公开密钥 e	00010001
}RSAPUBLICKEYBLOB, *PRSAPUBLICKEYBLOB;
<==*/


/*==>RSAPUBLICKEYBLOB RSA公钥结构
typedef struct Struct_RSAPRIVATEKEYBLOB{
	ULONG AlgID;									// RSA算法标识  SGD_RSA;	
	ULONG BitLen;									// 算法模长		1024
	BYTE Modulus[MAX_RSA_MODULUS_LEN];				//模数N		
	BYTE PublicExponent[MAX_RSA_EXPONENT_LEN];		//e
	BYTE PrivateExponent[MAX_RSA_MODULUS_LEN];		//私钥D  
	BYTE Prime1[MAX_RSA_MODULUS_LEN/2];				//p  1024模式下P为64字节,存放在Prime1的后64位
	BYTE Prime2[MAX_RSA_MODULUS_LEN/2];				//q	 1024模式下Q为64字节,存放在Prime2的后64位
	BYTE Prime1Exponent[MAX_RSA_MODULUS_LEN/2];		//dp 1024模式下DP为64字节,存放在Prime1Exponent的后64位
	BYTE Prime2Exponent[MAX_RSA_MODULUS_LEN/2];		//dq 1024模式下DQ为64字节,存放在Prime2Exponent的后64位
	BYTE Coefficient[MAX_RSA_MODULUS_LEN/2];		//coef 1024模式下coef为64字节,存放在Coefficient的后64位
}RSAPRIVATEKEYBLOB, *PRSAPRIVATEKEYBLOB;
<==*/

//用于RSA加解密填充
int rsa_padding_add_PKCS1_type_2_self(unsigned char *to, int tlen, const unsigned char *from, int flen);
void dev_rsa_funs_test()
{
	ULONG rv = 0;
	HANDLE hKey = NULL;

	RSAPUBLICKEYBLOB tRSAPubBlob;
	ULONG ulContainerType = 0, ulBitsLen = 0;

	BYTE bySignData[117] = {0}, bySignature[128] = {0};
	ULONG ulSignDataLen = 117, ulSignatureLen = 128;

	RSAPUBLICKEYBLOB tExtRSAPubBlob;
	BYTE byModulus[] = {
		0xB9,0x0F,0x1B,0x62,0x53,0xEF,0xDE,0x77,0x1A,0xE6,0x70,0xEA,0x2E,0xF6,0xC6,0x24,
		0xA1,0x73,0x77,0xE3,0x9F,0x4A,0x2D,0x8C,0x55,0x6D,0x04,0xA8,0x19,0x1E,0xCE,0x24,
		0x2F,0xE4,0x83,0x26,0x78,0x4B,0x1E,0x75,0x3A,0xA6,0x0C,0x80,0x31,0x6C,0x10,0xC4,
		0x54,0x32,0x0A,0xF0,0x9F,0xAE,0x5C,0x6C,0x9D,0xD7,0x92,0xE8,0x4B,0xE4,0xA9,0xA5,
		0x15,0x86,0xF7,0x1B,0x2C,0xB6,0x82,0x19,0x76,0x0D,0x23,0x35,0x99,0xC8,0x5B,0x16,
		0x99,0xA3,0x26,0x91,0x9B,0x74,0x79,0xD3,0x3A,0xD0,0xC9,0x86,0xC4,0x13,0xD0,0x9C,
		0x77,0x8E,0x29,0x16,0x00,0x50,0x62,0xF0,0x2B,0xB6,0xA2,0xE2,0xA6,0x42,0x3F,0xC8,
		0xBA,0x3E,0x75,0xA5,0x41,0xB3,0x06,0x62,0xBF,0xE7,0xA6,0x68,0xE0,0x0C,0x4A,0x63
	};
	BYTE byE[] = {0x00,0x01,0x00,0x01};
	BYTE byInData[128] = {0}, byOutData[128] = {0};
	ULONG byInDataLen = 128, byOutDataLen = 128;

	RSAPRIVATEKEYBLOB tExtRSAPriBlob;
	BYTE byP[] = {
		0xDA,0x73,0x7D,0xCB,0x35,0x3E,0x2F,0x19,0x38,0x91,0x41,0x70,0xC0,0xF0,0x35,0x42,
		0x08,0x71,0x54,0x1C,0x3F,0x0B,0x1D,0xB6,0xF6,0x2F,0xF6,0x29,0x26,0x2C,0xC2,0xEA,
		0xE0,0xF7,0x7C,0xAF,0x87,0x68,0xD6,0xC2,0x90,0x30,0xD5,0x1B,0x1D,0x3B,0xE7,0x41,
		0x70,0x5A,0xFE,0x88,0x49,0x00,0xD6,0x00,0x45,0x8D,0x5E,0xB4,0xC5,0x5D,0x96,0xD7
	};
	BYTE byQ[] = {
		0xD8,0xDE,0x42,0xE8,0x0B,0x5D,0x9B,0x57,0x1E,0xCC,0x44,0xAF,0xAE,0xBC,0xDC,0x78,
		0xB7,0xFC,0xE4,0x76,0x79,0xBE,0x87,0xDD,0xF2,0x50,0xB8,0x92,0x8A,0x36,0x04,0x23,
		0x59,0xB2,0x4F,0x74,0x54,0xC0,0x5C,0xAD,0xB4,0xE7,0xAE,0xF4,0xBD,0xEC,0xD1,0x8A,
		0x9A,0x69,0x31,0xE1,0xDC,0x55,0xF1,0x7D,0x52,0x0F,0xC1,0x00,0x69,0xCA,0xD3,0x55
	};
	BYTE byDP[] = {
		0x03,0xFF,0x1E,0xEB,0x0B,0xD3,0x52,0x6B,0x44,0xB4,0xAB,0x9C,0xD3,0x7A,0xD1,0x8E,
		0x9E,0xB6,0xEC,0x12,0x04,0x39,0x40,0xD6,0xEB,0x14,0x1F,0x8D,0xCB,0x2C,0x00,0x78,
		0xE9,0x9A,0xBD,0x86,0x3C,0x94,0xF7,0x70,0xE1,0xD0,0x72,0xE5,0xA7,0x18,0x44,0x77,
		0xD7,0x05,0x63,0x28,0xBD,0x25,0x2D,0xC5,0x1D,0x80,0xA3,0x9D,0xED,0x0A,0x74,0x4B
	};
	BYTE byDQ[] = {
		0x1A,0x3D,0xBA,0xA6,0xCD,0x49,0x44,0x54,0xA4,0x5B,0x5F,0x2C,0x4A,0xDE,0x7B,0x66,
		0xF8,0x0C,0x57,0xB0,0xA6,0x46,0x91,0xB6,0x1F,0x6D,0xF9,0x07,0x72,0x45,0xDA,0xF6,
		0x54,0x12,0x29,0x5F,0x10,0x2A,0x3E,0x8C,0x9E,0x49,0x32,0x78,0x56,0xCA,0xE3,0x07,
		0xFC,0x6B,0x22,0x28,0x0C,0x3B,0x31,0xFF,0x52,0x00,0xA9,0xFF,0xDC,0xCD,0x38,0x09
	};
	BYTE byINV[] = {
		0x38,0x12,0x0A,0xC9,0xF4,0x0F,0x9F,0x5E,0xC0,0xB5,0xE6,0x3D,0xC7,0xCB,0x4B,0x90,
		0xB7,0xED,0x76,0x22,0x34,0xE7,0xEF,0x2E,0xAD,0x2B,0xB7,0xC1,0xD3,0x31,0x60,0xC5,
		0x4D,0x51,0xD0,0x08,0x10,0x4F,0xA2,0x19,0x99,0xAE,0x00,0x2E,0x84,0x1E,0x31,0xE6,
		0x8C,0x71,0xD2,0x70,0xBD,0x2E,0xD7,0xAA,0xEB,0x77,0x5B,0x84,0x54,0xED,0x2D,0x16
	};

	BYTE bySymKey[16] = {0x1B,0x2F,0x2C,0x72,0xBB,0x43,0x5E,0xAD,0xED,0xDB,0x8B,0x80,0x70,0x0A,0x4F,0x64};
	BYTE bySymKeyFinal[128] = {0};
	BYTE byRSAPrikeyBlobCipher[2048] = {0};
	ULONG ulRSAPrikeyBlobCipherLen = 0;
	BLOCKCIPHERPARAM EncParam;
	//BYTE RSAPriKey[] = {		// P||Q||DP||DQ||INV
	//	0xDA,0x73,0x7D,0xCB,0x35,0x3E,0x2F,0x19,0x38,0x91,0x41,0x70,0xC0,0xF0,0x35,0x42,
	//	0x08,0x71,0x54,0x1C,0x3F,0x0B,0x1D,0xB6,0xF6,0x2F,0xF6,0x29,0x26,0x2C,0xC2,0xEA,
	//	0xE0,0xF7,0x7C,0xAF,0x87,0x68,0xD6,0xC2,0x90,0x30,0xD5,0x1B,0x1D,0x3B,0xE7,0x41,
	//	0x70,0x5A,0xFE,0x88,0x49,0x00,0xD6,0x00,0x45,0x8D,0x5E,0xB4,0xC5,0x5D,0x96,0xD7,
	//	0xD8,0xDE,0x42,0xE8,0x0B,0x5D,0x9B,0x57,0x1E,0xCC,0x44,0xAF,0xAE,0xBC,0xDC,0x78,
	//	0xB7,0xFC,0xE4,0x76,0x79,0xBE,0x87,0xDD,0xF2,0x50,0xB8,0x92,0x8A,0x36,0x04,0x23,
	//	0x59,0xB2,0x4F,0x74,0x54,0xC0,0x5C,0xAD,0xB4,0xE7,0xAE,0xF4,0xBD,0xEC,0xD1,0x8A,
	//	0x9A,0x69,0x31,0xE1,0xDC,0x55,0xF1,0x7D,0x52,0x0F,0xC1,0x00,0x69,0xCA,0xD3,0x55,
	//	0x03,0xFF,0x1E,0xEB,0x0B,0xD3,0x52,0x6B,0x44,0xB4,0xAB,0x9C,0xD3,0x7A,0xD1,0x8E,
	//	0x9E,0xB6,0xEC,0x12,0x04,0x39,0x40,0xD6,0xEB,0x14,0x1F,0x8D,0xCB,0x2C,0x00,0x78,
	//	0xE9,0x9A,0xBD,0x86,0x3C,0x94,0xF7,0x70,0xE1,0xD0,0x72,0xE5,0xA7,0x18,0x44,0x77,
	//	0xD7,0x05,0x63,0x28,0xBD,0x25,0x2D,0xC5,0x1D,0x80,0xA3,0x9D,0xED,0x0A,0x74,0x4B,
	//	0x1A,0x3D,0xBA,0xA6,0xCD,0x49,0x44,0x54,0xA4,0x5B,0x5F,0x2C,0x4A,0xDE,0x7B,0x66,
	//	0xF8,0x0C,0x57,0xB0,0xA6,0x46,0x91,0xB6,0x1F,0x6D,0xF9,0x07,0x72,0x45,0xDA,0xF6,
	//	0x54,0x12,0x29,0x5F,0x10,0x2A,0x3E,0x8C,0x9E,0x49,0x32,0x78,0x56,0xCA,0xE3,0x07,
	//	0xFC,0x6B,0x22,0x28,0x0C,0x3B,0x31,0xFF,0x52,0x00,0xA9,0xFF,0xDC,0xCD,0x38,0x09,
	//	0x38,0x12,0x0A,0xC9,0xF4,0x0F,0x9F,0x5E,0xC0,0xB5,0xE6,0x3D,0xC7,0xCB,0x4B,0x90,
	//	0xB7,0xED,0x76,0x22,0x34,0xE7,0xEF,0x2E,0xAD,0x2B,0xB7,0xC1,0xD3,0x31,0x60,0xC5,
	//	0x4D,0x51,0xD0,0x08,0x10,0x4F,0xA2,0x19,0x99,0xAE,0x00,0x2E,0x84,0x1E,0x31,0xE6,
	//	0x8C,0x71,0xD2,0x70,0xBD,0x2E,0xD7,0xAA,0xEB,0x77,0x5B,0x84,0x54,0xED,0x2D,0x16
	//};

	rv = SKF_DeleteContainer(hApplication, "Test_Container");
	rv = SKF_CreateContainer(hApplication, "Test_Container", &hContainer);

	// 生成RSA签名密钥对
	// ulBitsLen 为模长 1024/2048, pubBlob为导出的RSA公钥
	ulBitsLen = 1024;
	rv = SKF_GenRSAKeyPair(hContainer, ulBitsLen, &tRSAPubBlob);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_GenRSAKeyPair Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	rv = SKF_GetContainerType(hContainer, &ulContainerType);
	PrintMsg("SKF_GenRSAKeyPair ContainerType[%u] OK\n", ulContainerType);

	// RSA签名
	// bySignData签名数据, ulSignDataLen签名数据长度,不大于密钥模长-11, bySignature签名结果,ulSignatureLen签名结果长度
	rv = SKF_RSASignData(hContainer, bySignData, ulSignDataLen, bySignature, &ulSignatureLen);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_RSASignData Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_RSASignData OK\n");

	// RSA验签
	// ulSignatureLen签名结果长度,为公钥模长; tRSAPubBlob为验签使用的签名公钥
	rv = SKF_RSAVerify(hDev, &tRSAPubBlob, bySignData, ulSignDataLen, bySignature, ulSignatureLen);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_RSAVerify Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_RSAVerify OK\n");

	// RSA外来公钥运算(加密)
	// tExtRSAPubBlob为外来公钥, byInData为待运算数据,byInDataLen为待运算数据长度,必须为模长,不足补齐,byOutData为运算结果数据,byOutDataLen运算结果数据长度
	tExtRSAPubBlob.AlgID = SGD_RSA;
	tExtRSAPubBlob.BitLen = 1024;
	memcpy(tExtRSAPubBlob.Modulus + 128, byModulus, sizeof(byModulus));
	memcpy(tExtRSAPubBlob.PublicExponent, byE, sizeof(byE));
	memset(byInData, 0x05, byInDataLen);
	rv = SKF_ExtRSAPubKeyOperation(hDev, &tExtRSAPubBlob, byInData, byInDataLen, byOutData, &byOutDataLen);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_ExtRSAPubKeyOperation Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_ExtRSAPubKeyOperation OK\n");

	// RSA外来私钥运算(解密)
	tExtRSAPriBlob.AlgID = SGD_RSA;
	tExtRSAPriBlob.BitLen = 1024;
	memcpy(tExtRSAPriBlob.Prime1 + 64, byP, sizeof(byP));
	memcpy(tExtRSAPriBlob.Prime2 + 64, byQ, sizeof(byQ));
	memcpy(tExtRSAPriBlob.Prime1Exponent + 64, byDP, sizeof(byDP));
	memcpy(tExtRSAPriBlob.Prime2Exponent + 64, byDQ, sizeof(byDQ));
	memcpy(tExtRSAPriBlob.PublicExponent, byE, sizeof(byE));
	memcpy(tExtRSAPriBlob.Coefficient + 64, byINV, sizeof(byINV));
	rv = SKF_ExtRSAPriKeyOperation(hDev, &tExtRSAPriBlob, byOutData, byOutDataLen, byInData, &byInDataLen);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_ExtRSAPriKeyOperation Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_ExtRSAPriKeyOperation OK\n");

	// RSA生成并导出会话密钥
	// 使用tExtRSAPubBlob加密产生的会话密钥, 返回加密结果密文byOutData和会话密钥句柄hKey
	rv = SKF_RSAExportSessionKey(hContainer, SGD_SM1_ECB, &tExtRSAPubBlob, byOutData, &byOutDataLen, &hKey);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_RSAExportSessionKey Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_RSAExportSessionKey OK\n");
	rv = SKF_CloseHandle(hKey);

	// 导入RSA加密密钥对
	//==> 以下模拟 应用方 获取会话密钥密文、私钥密文过程
	// 将密钥填充到算法模长长度
	rsa_padding_add_PKCS1_type_2_self(bySymKeyFinal, 128, bySymKey, 16);
	// 使用签名公钥加密会话密钥, 得到会话密钥密文
	rv = SKF_ExtRSAPubKeyOperation(hDev, &tRSAPubBlob, bySymKeyFinal, 128, byOutData, &byOutDataLen);
	// 使用会话密钥加密RSA私钥
	rv = SKF_SetSymmKey(hDev, bySymKey, SGD_SM1_ECB, &hKey);
	EncParam.IVLen = 0;
	EncParam.PaddingType = 1;
	rv = SKF_EncryptInit(hKey, EncParam);
	rv = SKF_Encrypt(hKey, (BYTE*)&tExtRSAPriBlob, sizeof(RSAPRIVATEKEYBLOB), NULL, &ulRSAPrikeyBlobCipherLen);
	rv = SKF_Encrypt(hKey, (BYTE*)&tExtRSAPriBlob, sizeof(RSAPRIVATEKEYBLOB), byRSAPrikeyBlobCipher, &ulRSAPrikeyBlobCipherLen);
	rv = SKF_CloseHandle(hKey);
	//<== end
	rv = SKF_ImportRSAKeyPair(hContainer, SGD_SM1_ECB, byOutData, byOutDataLen, byRSAPrikeyBlobCipher, ulRSAPrikeyBlobCipherLen);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_ImportRSAKeyPair Wrong\n");
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_ImportRSAKeyPair OK\n");

	// 加密公钥对会话密钥加密, 得到会话密钥密文
	//==> 以下模拟 应用方使用SKF_ImportECCKeyPair导入的公私钥对中的公钥对会话密钥加密
	memset(byOutData, 0x00, 128);
	rv = SKF_ExtRSAPubKeyOperation(hDev, &tExtRSAPubBlob, bySymKeyFinal, 128, byOutData, &byOutDataLen);
	//<== end
	// SGD_SM1_ECB标识会话密钥算法标识, byOutData为使用加解密密钥对公钥对会话密钥加密后的密文
	rv = SKF_ImportSessionKey (hContainer, SGD_SM1_ECB, byOutData, byOutDataLen, &hKey);
	if (rv != SAR_OK)
	{
		PrintMsg("SKF_ImportSessionKey Wrong,%04x\n", rv);
		fflush(stdin);
		getchar();
		return ;
	}
	PrintMsg("SKF_ImportSessionKey OK\n");
	rv = SKF_CloseHandle(hKey);
	rv = SKF_CloseContainer(hContainer);
}

int rsa_padding_add_PKCS1_type_2_self(unsigned char *to, int tlen, const unsigned char *from, int flen)
{
	int i,j;
	unsigned char *p;

	if (flen > (tlen-11))
	{
		return(-1);
	}

	p=(unsigned char *)to;

	*(p++)=0;
	*(p++)=2; 
	j=tlen-3-flen;
	for(i = 0; i <j ; i++)
	{
		do 
		{
			*p = rand() & 0xff;
		} while (*p == '\0');
		p++;
	}

	*(p++)='\0';

	memcpy(p,from,(unsigned int)flen);
	return(0);
}
