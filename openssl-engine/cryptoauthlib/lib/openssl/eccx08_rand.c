/**
 * \brief OpenSSL ENGINE Random Number Generator Interface for ATECCx08 devices
 *
 * \copyright Copyright (c) 2017 Microchip Technology Inc. and its subsidiaries (Microchip). All rights reserved.
 *
 * \page License
 *
 * You are permitted to use this software and its derivatives with Microchip
 * products. Redistribution and use in source and binary forms, with or without
 * modification, is permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Microchip may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with a
 *    Microchip integrated circuit.
 *
 * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL MICROCHIP BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "eccx08_engine.h"

#if ATCA_OPENSSL_ENGINE_ENABLE_RAND
#include "eccx08_engine_internal.h"

static uint32_t total_num = 0;

#if ATCA_OPENSSL_ENGINE_RAND_SEED_ONLY

/** \brief Max number of pseudo-random bytes - re-seed after this number
Only applies when ATCA_OPENSSL_ENGINE_RAND_SEED_ONLY is set to 1 */
#ifndef MAX_RAND_BYTES
#define MAX_RAND_BYTES                          (10037)
#endif

/**
 * \brief Generates a random bytes stream. The ATECCX08 TRNG is
 *        used to seed a standard OpenSSL PRNG (RAND_SSLeay()),
 *        which is used to produce the random stream then. The
 *        PRNG is reseeded after MAX_RAND_BYTES are generated
 *
 * \param[out] buf - a pointer to buffer for the random byte
 *       stream. The caller must allocate enough space in the
 *       buffer in order to fit all generated bytes.
 * \param[in] num - number of bytes to generate
 * \return 1 for success
 */
static int RAND_eccx08_rand_bytes(unsigned char *buf, int num)
{
    int rc = 0;
    uint32_t atcab_buf[ATCA_BLOCK_SIZE / sizeof(uint32_t)];
    double entropy;
    const RAND_METHOD *meth_rand = RAND_SSLeay();
    ATCA_STATUS status = ATCA_GEN_FAIL;

    if (total_num > MAX_RAND_BYTES) {
        total_num = 0;
    }
    if (total_num == 0) {
        eccx08_debug("RAND_eccx08_rand_bytes() -  hw\n");
        status = atcab_init_safe(pCfg);
        if (status != ATCA_SUCCESS) goto done;
        status = atcab_random((uint8_t *)atcab_buf);
        if (status != ATCA_SUCCESS) goto done;
        status = atcab_release_safe();
        if (status != ATCA_SUCCESS) goto done;
        entropy = (double)atcab_buf[0];
        meth_rand->add(buf, num, entropy);
    }
    total_num += num;
    rc = meth_rand->bytes(buf, num);
done:
    return (rc);
}

/**
*
* \brief Return success if totally generated number of random
*        bytes after the last reseed is less than
*        MAX_RAND_BYTES
*
* \return 1 for success
*/
static int RAND_eccx08_rand_status(void)
{
    DEBUG_ENGINE("Entered\n");
    if (total_num > MAX_RAND_BYTES) {
        return ENGINE_OPENSSL_FAILURE;
    }
    return ENGINE_OPENSSL_SUCCESS;
}

#else
/**
* \brief Generates a random bytes stream using the ATECCx08 hardware RNG
*
* \param[out] buf - a pointer to buffer for the random byte stream. The caller
*       must allocate enough space in the buffer to fit all generated bytes.
* \param[in] num - number of bytes to generate
* \return 1 for success
*/
static int RAND_eccx08_rand_bytes(unsigned char *buf, int num)
{
    DEBUG_ENGINE("Entered\n");
    ATCA_STATUS status = ATCA_SUCCESS;

    if (!buf || !num)
    {
        return ENGINE_OPENSSL_FAILURE;
    }

    if (ATCA_SUCCESS != (status = atcab_init_safe(pCfg)))
    {
        DEBUG_ENGINE("Init fail: %#x\n", status);
        return ENGINE_OPENSSL_FAILURE;
    }

    do
    {
        if (ATCA_BLOCK_SIZE <= num)
        {
            if (ATCA_SUCCESS == (status = atcab_random((uint8_t *)buf)))
            {
                num -= ATCA_BLOCK_SIZE;
                //(uint8_t*)buf += ATCA_BLOCK_SIZE;
                buf = (uint8_t*)buf + ATCA_BLOCK_SIZE;
            }
        }
        else
        {
            uint8_t atcab_buf[ATCA_BLOCK_SIZE];
            if (ATCA_SUCCESS == (status = atcab_random((uint8_t *)atcab_buf)))
            {
                memcpy(buf, atcab_buf, num);
                num = 0;
            }
        }
        DEBUG_ENGINE("Buf: %p, Num: %d\n", buf, num);
    } while (0 < num && !status);

    (void)atcab_release_safe();

    if (num)
    {
        DEBUG_ENGINE("Failed: %d, Remaining: %d\n", status, num);
        return ENGINE_OPENSSL_FAILURE;
    }

    DEBUG_ENGINE("Finished\n");
    return ENGINE_OPENSSL_SUCCESS;
}

static int RAND_eccx08_rand_status(void)
{
    return ENGINE_OPENSSL_SUCCESS;
}
#endif

/**
 *  \brief eccx08_rand is an OpenSSL RAND_METHOD structure
 *         specific to the ateccx08 engine.
 *         See the crypto/rand/rand.h file for details on the
 *         struct rand_meth_st
 */
RAND_METHOD eccx08_rand = {  // see crypto/rand/rand.h struct rand_meth_st
    NULL,                   // seed()
    RAND_eccx08_rand_bytes, // bytes()
    NULL,                   // cleanup()
    NULL,                   // add()
    RAND_eccx08_rand_bytes, // pseudorand()
    RAND_eccx08_rand_status // status()
};

/**
 *
 * \brief Initialize the RAND method for ateccx08 engine
 *
 * \return 1 for success
 */
int eccx08_rand_init(void)
{
    const RAND_METHOD *meth_rand = RAND_SSLeay();

    DEBUG_ENGINE("Entered\n");

    /* We use OpenSSL (SSLeay) meth to supply what we don't provide */
    eccx08_rand.seed = meth_rand->seed;
    eccx08_rand.cleanup = meth_rand->cleanup;

    return ENGINE_OPENSSL_SUCCESS;
}

#endif //ATCA_OPENSSL_ENGINE_ENABLE_RAND
